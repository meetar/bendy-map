# by @meetar based on tilt-gotham by @patriciogv - 2015

cameras:
    perspective:
        type: perspective
        fov: 55.
lights:
    # directional1:
    #     type: directional
    #     direction: [-1.,-1.,-0.5]
    #     ambient: [0.384, 0.384, 0.384]
    #     diffuse: [0.945, 0.945, 0.945]
    point1:
        type: point
        position: [0, -4000, 2000]
        origin: ground
        ambient: [0.384, 0.384, 0.384]
        diffuse: [0.620, 0.620, 0.620]
styles:
    tilt:
        animated: true
        base: polygons
        shaders:
            uniforms:
                u_t: 1.
                u_u: 3.68
                u_v: .001
                u_yoffset: -800.
                u_zoffset: 0.
            blocks:
                global: |
                    mat3 rotateX3D(float phi){
                        return mat3(
                            vec3(1.,0.,0.),
                            vec3(0.,cos(phi),-sin(phi)),
                            vec3(0.,sin(phi),cos(phi))
                            );
                    }
                    mat3 rotateZ3D(float psi){
                        return mat3(
                            vec3(cos(psi),-sin(psi),0.),
                            vec3(sin(psi),cos(psi),0.),
                            vec3(0.,0.,1.)
                            );
                    }
                color: color = vec4(1.);
                position: |
                    float meter_pixels = u_meters_per_pixel / u_device_pixel_ratio;
                    vec2 rez = u_resolution * meter_pixels;
                    vec2 center = u_map_position.xy;
                    float y_range = (rez.y / 2.); 
                    float top = center.y + y_range;
                    float bottom = center.y - y_range;

                    // twist map in z (manhattan angle happens to be almost exactly half a radian)
                    position.xyz *= rotateZ3D(.5);

                    // rotate map in x to flat, edge-on
                    vec3 new = rotateX3D(1.3) * position.xyz;
                    // new.y += 300.;
                    // new.z -= 1000.;
                     
                    // mix between vertical and horizontal maps, depending on y
                    // position.xyz = mix(position.xyz, new.xyz, (position.y - bottom) / u_resolution.y);
                    position.xyz = mix(position.xyz, new.xyz, (-position.y + rez.y/2.)/rez.y);
                    

   
    roads:
        animated: false
        texcoords: true
        base: lines
        mix: tilt
sources:
    osm:
        type: TopoJSON
        url:  //vector.mapzen.com/osm/all/{z}/{x}/{y}.topojson?api_key=vector-tiles-_vxMzew
layers:
    water:
        data: { source: osm }
        draw:
            roads:
                order: 2
                width: 3px
                color: '#353535'
    earth:
        data: { source: osm }
        draw:
            roads:
                order: 0
                width: 3px
                color: '#555'
    roads:
        data: { source: osm }
        filter: { not: { highway: service, kind: rail } }
        properties: { width: 3 }
        draw:
            roads:
                order: 3
                color: lightblue
                width: 15
    buildings:
        data: { source: osm }
        draw:
            tilt:
                order: 5
                color: white
                extrude: true
