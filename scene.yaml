# Author @patriciogv - 2015

cameras:
    perspective:
        type: perspective
        vanishing_point: [0, -500]
lights:
    directional1:
        type: directional
        direction: [-1.,-1.,-0.5]
        ambient: .3
        diffuse: .5
        specular: 1.
styles:
    tilt:
        animated: true
        base: polygons
        shaders:
            uniforms:
                u_t: 1.
                u_u: -1.4
                u_v: .001
                u_yoffset: -800.
                u_zoffset: 0.
            blocks:
                global: |
                    mat3 rotateX3D(float phi){
                        return mat3(
                            vec3(1.,0.,0.),
                            vec3(0.,cos(phi),-sin(phi)),
                            vec3(0.,sin(phi),cos(phi))
                            );
                    }
                    mat3 rotateZ3D(float psi){
                        return mat3(
                            vec3(cos(psi),-sin(psi),0.),
                            vec3(sin(psi),cos(psi),0.),
                            vec3(0.,0.,1.)
                            );
                    }
                position: |
                    // float t = u_time*0.05; 
                    float t = 1.;
                    float u = 0.;
                    // position.xyz = rotateX3D(abs(cos(t))) * rotateZ3D(abs(sin(t))*.5) * position.xyz;
                    vec3 new = rotateX3D(cos(u_t)) * rotateZ3D(sin(u_u)*.5) * position.xyz;
                    position.xyz = new.xyz;
                    position.xyz = vec3(new.x, position.y - u_yoffset, new.z*position.y*-1.*u_v - u_zoffset);
    pol:
        base: polygons
        mix: tilt
    tools:
        mix: tilt
        base: polygons
        shaders:
            blocks:
                global: |
                    float fade(float z) { return smoothstep(.0,.5,z) - smoothstep(.5,1.,z); }
                    float grid(vec2 pos, float zoom, float lineWidth){
                        pos = fract(pos*zoom);
                        pos += .5;
                        vec2 g = smoothstep(vec2(0.5-lineWidth),vec2(0.5),pos)-smoothstep(vec2(0.5),vec2(0.5+lineWidth),pos);
                        return clamp(g.x+g.y,0.0,1.);
                    }
                    float infinitGrid(vec2 st, float zoom){
                        float grid1 = grid(st,.0000004*pow(2.,floor(zoom/2.)*2.),.05);
                        float grid2 = grid(st,.0000001*pow(2.,floor((zoom+1.)/2.)*2.),.05);
                        return  grid1 * fade(fract(zoom/2.)) + grid2 * fade(fract((zoom+1.)/2.));
                    }
                    float random(in float x){return fract(sin(x)*43758.5453);}
                    float random(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }
                    vec2 random2( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }
                    float noise(vec2 x) {
                        vec2 i = floor(x);
                        vec2 f = fract(x);
                        float a = random(i);
                        float b = random(i + vec2(1.0, 0.0));
                        float c = random(i + vec2(0.0, 1.0));
                        float d = random(i + vec2(1.0, 1.0));
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                    }
                    float fbm( in vec2 p ){
                        float s = 0.0;
                        float m = 0.0;
                        float a = 0.5;
                        for(int i=0; i<2; i++ ){
                            s += a * noise(p);
                            m += a;
                            a *= 0.5;
                            p *= 2.0;
                        }
                        return s/m;
                    }
                    float grain(vec2 pos){
                        vec2 st = pos/u_resolution.xy-vec2(.5);
                        return dot(st,st)+(fbm(pos*0.6)*0.1);
                    }
                    vec3 voronoi(vec2 st) {
                        vec2 ipos = floor(st);
                        vec2 fpos = fract(st);
                        vec3 m = vec3( 8.0 );
                        for( int j=-1; j<=1; j++ ){
                            for( int i=-1; i<=1; i++ ){
                                vec2  g = vec2( float(i), float(j) );
                                vec2  o = random2( ipos + g );
                                vec2  r = g - fpos + o;
                                float d = dot( r, r );
                                if( d<m.x )
                                    m = vec3( d, o );
                            }
                        }
                        return m;
                    }
    grain:
        base: polygons
        mix: tools
        shaders:
            blocks:
                filter: |
                    color.rgb -= grain(gl_FragCoord.xy)*0.3;
    roads:
        animated: false
        texcoords: true
        base: lines
        mix: tools
sources:
    osm:
        type: TopoJSON
        url:  //vector.mapzen.com/osm/all/{z}/{x}/{y}.topojson?api_key=vector-tiles-JUsa0Gc
layers:
    water:
        data: { source: osm }
        draw:
            tilt:
                order: 2
                color: '#353535'
    earth:
        data: { source: osm }
        draw:
            roads:
                order: 0
                color: '#555'
    # landuse:
    #     data: { source: osm }
    #     draw:
    #         tilt:
    #             order: 1
    #             color: '#666'
    roads:
        data: { source: osm }
        filter: { not: { highway: service, kind: rail } }
        properties: { width: 3 }
        draw:
            roads:
                order: 3
                color: red
                width: 15
    buildings:
        data: { source: osm }
        filter: { $zoom: { min: 10 } }
        draw:
            tilt:
                order: 5
                color: white
                extrude: function () { return feature.height > 0 || $zoom >= 16; }
